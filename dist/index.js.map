{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import get from 'lodash.get'\nimport set from 'lodash.set'\nimport isArray from 'lodash.isarray'\nimport isPlainObject from 'lodash.isplainobject'\n\ntype Options = {\n  strict?: boolean\n  keepTypeof?: boolean\n  stringifyTypeof?: boolean\n  [key: string]: any\n}\n\nconst castBoolean = (strOrBool) => {\n  if ([false, 'false'].includes(strOrBool)) {\n    return false\n  }\n\n  if ([true, 'true'].includes(strOrBool)) {\n    return true\n  }\n\n  return strOrBool\n}\n\nconst isFalsy = (bool) => ['false'].includes(String(bool))\n\nconst isTruthy = (bool) => ['true'].includes(String(bool))\n\nconst isString = (data) => ['string'].includes(typeof data)\n\nconst isNullify = (data) => [undefined, null].includes(data)\n\nclass DryReplacer {\n  data: object\n  strict?: boolean = true\n  keepTypeof?: boolean = false\n  stringifyTypeof?: boolean = false\n\n  constructor(data: object, options?: Options) {\n    this.data = data\n    this.strict = options?.strict\n    this.keepTypeof = options?.keepTypeof\n    this.stringifyTypeof = options?.stringifyTypeof\n  }\n\n  replaceValue(key: string, value: any, data: object, template: object): void {\n    let matchedArray = String(value).match(/{{.*?}}/g) // extract only {{}} pattern\n\n    if (matchedArray) {\n      for (let item of matchedArray.reverse()) {\n        let patternKey = item.replace(/[{}]/g, '')\n        let spotting = get(template, key)\n\n        let valueFromData = get(data, patternKey)\n        let newValue = valueFromData\n\n        if (isNullify(valueFromData)) {\n          valueFromData = ''\n        }\n\n        if (isFalsy(valueFromData) || isTruthy(valueFromData)) {\n          valueFromData = String(valueFromData)\n        }\n\n        if (matchedArray.length > 1) {\n          if (this.stringifyTypeof && (Array.isArray(valueFromData) || isPlainObject(valueFromData))) {\n            valueFromData = JSON.stringify(valueFromData)\n          }\n        }\n\n        if (isString(valueFromData)) {\n          if (this.strict) {\n            newValue = spotting.replace(item, valueFromData)\n          } else {\n            newValue = spotting.replace(item, valueFromData || '')\n          }\n        }\n\n        if (['number'].includes(typeof valueFromData)) {\n          newValue = spotting.replace(item, valueFromData)\n\n          if (this.keepTypeof && /^-?\\.?_?\\d+$/.test(newValue)) {\n            newValue = Number(newValue)\n          }\n        }\n\n        if (isFalsy(newValue)) {\n          newValue = castBoolean(newValue)\n        }\n\n        if (isTruthy(newValue)) {\n          newValue = castBoolean(newValue)\n        }\n\n        set(template, key, newValue)\n      }\n    }\n  }\n\n  recursiveReplace(data: object, template: any): object {\n    for (let key of Object.keys(template)) {\n      let value = template[key]\n\n      if (isPlainObject(value)) {\n        this.recursiveReplace(data, value)\n      } else if (isArray(value)) {\n        value.map((item) => this.recursiveReplace(data, item))\n      } else {\n        this.replaceValue(key, value, data, template)\n      }\n    }\n    return template\n  }\n\n  try(jsonToParse: string, options = {}): object {\n    if (options) {\n      Object.assign(this, options)\n    }\n\n    let template = JSON.parse(jsonToParse)\n    this.recursiveReplace(this.data, template)\n\n    return template\n  }\n}\n\nexport default DryReplacer\n"],"names":["castBoolean","strOrBool","includes","isFalsy","bool","String","isString","data","undefined","options","strict","keepTypeof","this","stringifyTypeof","replaceValue","key","value","template","match","matchedArray","_step","_iterator","_createForOfIteratorHelperLoose","reverse","done","item","patternKey","replace","get","newValue","valueFromData","isNullify","isTruthy","length","Array","isArray","isPlainObject","JSON","stringify","spotting","test","Number","set","recursiveReplace","_this","_i","_Object$keys","Object","keys","map","_proto","jsonToParse","assign","parse","DryReplacer"],"mappings":"wXAYA,IAAMA,EAAc,SAACC,GACnB,OAAI,EAAC,EAAO,SAASC,SAASD,OAI1B,EAAC,EAAM,QAAQC,SAASD,MAK9B,EAEME,EAAU,SAACC,SAAS,CAAC,SAASF,SAASG,OAAOD,GAAM,IAEzC,SAACA,GAAS,MAAA,CAAC,QAAQF,SAASG,OAAOD,GAAM,EAE5CE,EAAG,SAACC,GAAI,MAAK,CAAC,UAAUL,gBAAoBK,EAAC,IAEzC,SAACA,GAAS,MAAA,MAACC,EAAW,MAAMN,SAASK,EAAK,yCAQ1D,SAAYA,EAAAA,EAAcE,GAL1BF,KAAAA,UACAG,EAAAA,KAAAA,QAAmB,EACnBC,KAAAA,YAAuB,EAAKC,KAC5BC,iBAA4B,EAG1BD,KAAKL,KAAOA,EACZK,KAAKF,OAAgB,MAAPD,OAAO,EAAPA,EAASC,OACvBE,KAAKD,WAAoB,MAAPF,OAAO,EAAPA,EAASE,WAC3BC,KAAKC,sBAAkBJ,SAAAA,EAASI,eAClC,CAAC,kBAgFA,SA9EDC,aAAA,SAAaC,EAAaC,EAAYT,EAAcU,GAClD,MAAmBZ,OAAOW,GAAOE,MAAM,YAEvC,GAAIC,EACF,IAAA,IAAuCC,EAAvCC,2qBAAAC,CAAiBH,EAAaI,aAASH,EAAAC,KAAAG,MAAE,CAAhCC,IAAAA,UACHC,EAAaD,EAAKE,QAAQ,QAAS,MACxBC,EAAG,QAACX,EAAUF,KAETa,EAAAA,QAAIrB,EAAMmB,GAClBG,EAAGC,EAEXC,EAAUD,KACZA,EAAgB,KAGd3B,EAAQ2B,IAAkBE,EAASF,MACrCA,EAAgBzB,OAAOyB,IAGrBX,EAAac,OAAS,GACpBrB,KAAKC,kBAAoBqB,MAAMC,QAAQL,IAAkBM,UAAcN,MACzEA,EAAgBO,KAAKC,UAAUR,IAI/BxB,EAASwB,KAETD,EAAWU,EAASZ,QAAQF,EAD1Bb,KAAKF,OAC2BoB,EAEAA,GAAiB,KAInD,CAAC,UAAU5B,qBACb2B,EAAWU,EAASZ,QAAQF,EAAMK,GAE9BlB,KAAKD,YAAc,eAAe6B,KAAKX,KACzCA,EAAWY,OAAOZ,KAIlB1B,EAAQ0B,KACVA,EAAW7B,EAAY6B,IAGrBG,EAASH,KACXA,EAAW7B,EAAY6B,IAGzBa,EAAAA,QAAIzB,EAAUF,EAAKc,EACpB,CAEL,EAEAc,EAAAA,iBAAA,SAAiBpC,EAAcU,GAC7B,IAAA,IAAA2B,EAAAhC,KAAAiC,EAAA,EAAAC,EAAgBC,OAAOC,KAAK/B,kBAAW,CAAlC,IAAOF,EAAA+B,EAAAD,GACD7B,EAAGC,EAASF,GAEjBqB,UAAcpB,GAChBJ,KAAK+B,iBAAiBpC,EAAMS,GACnBmB,EAAO,QAACnB,GACjBA,EAAMiC,IAAI,SAACxB,UAAamB,EAACD,iBAAiBpC,EAAMkB,EAAK,GAErDb,KAAKE,aAAaC,EAAKC,EAAOT,EAAMU,EAEvC,CACD,OAAOA,CACT,EAACiC,EAAA,IAED,SAAIC,EAAqB1C,YAAAA,IAAAA,EAAU,CAAA,GAC7BA,GACFsC,OAAOK,OAAOxC,KAAMH,GAGtB,IAAYQ,EAAGoB,KAAKgB,MAAMF,GAG1B,OAFAvC,KAAK+B,iBAAiB/B,KAAKL,KAAMU,GAE1BA,CACT,EAACqC,CAAA"}