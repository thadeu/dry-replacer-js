{"version":3,"file":"index.mjs","sources":["../src/index.ts"],"sourcesContent":["import get from 'lodash.get'\nimport set from 'lodash.set'\nimport isArray from 'lodash.isarray'\nimport isPlainObject from 'lodash.isplainobject'\n\ntype Options = {\n  strict?: boolean\n  keepTypeof?: boolean\n}\n\nclass DryReplacer {\n  data: object\n  strict?: boolean = true\n  keepTypeof?: boolean = false\n\n  constructor(data: object, options?: Options) {\n    this.data = data\n    this.strict = options?.strict\n    this.keepTypeof = options?.keepTypeof\n  }\n\n  replaceValue(key: string, value: any, data: object, template: object): void {\n    let matchedArray = String(value).match(/{{.*?}}/g) // extract only {{}} pattern\n\n    if (matchedArray) {\n      for (let item of matchedArray.reverse()) {\n        let patternKey = item.replace(/[{}]/g, '')\n        let spotting = get(template, key)\n\n        let valueFromData = get(data, patternKey)\n        let newValue = valueFromData\n\n        const isStringOrFalsy = [\n          'undefined',\n          undefined,\n          null,\n          'string',\n        ].includes(typeof valueFromData)\n\n        if (isStringOrFalsy) {\n          if (this.strict) {\n            newValue = spotting.replace(item, valueFromData)\n          } else {\n            newValue = spotting.replace(item, valueFromData || '')\n          }\n        }\n\n        if (['number'].includes(typeof valueFromData)) {\n          newValue = spotting.replace(item, valueFromData)\n\n          if (this.keepTypeof && /^-?\\.?_?\\d+$/.test(newValue)) {\n            newValue = Number(newValue)\n          }\n        }\n\n        set(template, key, newValue)\n      }\n    }\n  }\n\n  recursiveReplace(data: object, template: any): object {\n    for (let key of Object.keys(template)) {\n      let value = template[key]\n\n      if (isPlainObject(value)) {\n        this.recursiveReplace(data, value)\n      } else if (isArray(value)) {\n        value.map((item) => this.recursiveReplace(data, item))\n      } else {\n        this.replaceValue(key, value, data, template)\n      }\n    }\n    return template\n  }\n\n  try(jsonToParse: string): object {\n    let template = JSON.parse(jsonToParse)\n    this.recursiveReplace(this.data, template)\n\n    return template\n  }\n}\n\nexport default DryReplacer\n"],"names":["DryReplacer","data","options","strict","keepTypeof","this","replaceValue","key","value","template","matchedArray","String","match","reverse","item","patternKey","replace","spotting","get","newValue","valueFromData","undefined","includes","test","Number","set","_proto","recursiveReplace","_this","_i","_Object$keys","Object","keys","isPlainObject","isArray","map","jsonToParse","JSON","parse"],"mappings":"gOAUMA,IAAAA,eAKJ,WAAA,SAAAA,EAAYC,EAAcC,GAJ1BD,KAAAA,iBACAE,QAAmB,EACnBC,KAAAA,YAAuB,EAGrBC,KAAKJ,KAAOA,EACZI,KAAKF,aAASD,SAAAA,EAASC,OACvBE,KAAKD,WAAaF,MAAAA,OAAAA,EAAAA,EAASE,UAC7B,CAAC,kBA6DA,SA3DDE,aAAA,SAAaC,EAAaC,EAAYP,EAAcQ,GAClD,IAAIC,EAAeC,OAAOH,GAAOI,MAAM,YAEvC,GAAIF,EACF,IAAiBA,MAAAA,2qBAAAA,CAAAA,EAAaG,0BAAW,CAAhCC,IAAAA,UACHC,EAAaD,EAAKE,QAAQ,QAAS,IACnCC,EAAWC,EAAIT,EAAUF,KAETW,EAAIjB,EAAMc,GAClBI,EAAGC,EAES,CACtB,iBACAC,EACA,KACA,UACAC,gBAA6BF,KAI3BD,EAAWF,EAASD,QAAQF,EAD1BT,KAAKF,OAC2BiB,EAEAA,GAAiB,KAInD,CAAC,UAAUE,gBAAgBF,KAC7BD,EAAWF,EAASD,QAAQF,EAAMM,GAE9Bf,KAAKD,YAAc,eAAemB,KAAKJ,KACzCA,EAAWK,OAAOL,KAItBM,EAAIhB,EAAUF,EAAKY,EACpB,CAEL,EAACO,EAEDC,iBAAA,SAAiB1B,EAAcQ,GAC7B,IAAA,IAAAmB,EAAAvB,KAAAwB,EAAA,EAAAC,EAAgBC,OAAOC,KAAKvB,kBAAW,CAAlC,MACHqB,EAAAD,KAAYpB,EAASF,GAEjB0B,EAAczB,GAChBH,KAAKsB,iBAAiB1B,EAAMO,GACnB0B,EAAQ1B,GACjBA,EAAM2B,IAAI,SAACrB,GAAI,SAAUa,iBAAiB1B,EAAMa,EAAK,GAErDT,KAAKC,aAAaC,EAAKC,EAAOP,EAAMQ,EAEvC,CACD,OACFA,CAAA,QAEA,SAAI2B,GACF,MAAeC,KAAKC,MAAMF,GAG1B,OAFA/B,KAAKsB,iBAAiBtB,KAAKJ,KAAMQ,IAGnC,EAACT,CAAA,CAjED"}